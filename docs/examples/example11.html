
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" /><script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-110543543-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
    <title>Monte Carlo Sampling Expectation Values of Obsevables &#8212; QuSpin 0.3.7 documentation</title>
    <link rel="stylesheet" href="../static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../static/documentation_options.js"></script>
    <script src="../static/jquery.js"></script>
    <script src="../static/underscore.js"></script>
    <script src="../static/doctools.js"></script>
    <script src="../static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">QuSpin 0.3.7 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <style> .red {color:#ff0000; font-weight:bold; font-style:italic; } </style>
<style> .green {color:#00b200; font-weight:bold; font-style:italic; } </style>
<style> .magenta {color:#FF33F3; font-weight:bold; font-style:italic; } </style>
<style> .orange {color:#FE8E02; font-weight:bold; font-style:italic; } </style><div class="section" id="monte-carlo-sampling-expectation-values-of-obsevables">
<span id="example11-label"></span><h1>Monte Carlo Sampling Expectation Values of Obsevables<a class="headerlink" href="#monte-carlo-sampling-expectation-values-of-obsevables" title="Permalink to this headline">¶</a></h1>
<p><a class="reference download internal" download="" href="../downloads/560f8fd39e62335be399e802c1b3cbe7/example11.py"><code class="xref download docutils literal notranslate"><span class="pre">download</span> <span class="pre">script</span></code></a></p>
<p>The example below demonstrates how to use the <cite>*_basis_general</cite> methods <cite>Op_bra_ket()</cite>, <cite>representative()</cite> and <cite>get_amp()</cite>, which do not require computing all basis states, to do Monte-Carlo sampling in a symmetry-reduced subspace.</p>
<p>Depending on the problem of interest, sampling in the symmetry-reduced Hilbert space, as opposed to sampling in the full Hilbert space, may or may not be advantages
(in terms of speed and efficiency).</p>
</div>
<div class="section" id="physics-setup">
<h1>Physics Setup<a class="headerlink" href="#physics-setup" title="Permalink to this headline">¶</a></h1>
<p>The expectation value of an operator <span class="math notranslate nohighlight">\(H\)</span> in a state <span class="math notranslate nohighlight">\(\psi\)</span> can be written as</p>
<div class="math notranslate nohighlight">
\[\langle\psi|H|\psi\rangle = \sum_{s,s'} \psi_s^\ast H_{ss'}\psi_{s'} = \sum_s |\psi_s|^2 E_{s},\qquad E_s = \frac{1}{\psi_s}\sum_{s'}H_{ss'}\psi_{s'},\]</div>
<p>where <span class="math notranslate nohighlight">\(\{|s\rangle\}_s\)</span> can be any basis, in particular the Fock (<span class="math notranslate nohighlight">\(z\)</span>-) basis used in QuSpin.</p>
<p>The above expression suggests that one can use sampling methods, such as Monte Carlo, to estimate the expectation value of <span class="math notranslate nohighlight">\(\langle\psi|H|\psi\rangle\)</span> using the quantity <span class="math notranslate nohighlight">\(E_s\)</span> (sometimes referred to as the local energy) evaluated in samples drawn from the probability distribution <span class="math notranslate nohighlight">\(p_s=|\psi_s|^2\)</span>. If we have: (i) a function <span class="math notranslate nohighlight">\(s\mapsto\psi_s\)</span> which computes the amplitudes for every spin configuration <span class="math notranslate nohighlight">\(s\)</span>, and (ii) the matrix elements <span class="math notranslate nohighlight">\(H_{ss'}\)</span>, then</p>
<div class="math notranslate nohighlight">
\[\langle\psi|H|\psi\rangle \approx \frac{1}{N_\mathrm{MC}}\sum_{s\in\mathcal{S}} E_s,\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathcal{S}\)</span> contains <span class="math notranslate nohighlight">\(N_\mathrm{MC}\)</span> spin configurations sampled from <span class="math notranslate nohighlight">\(p_s=|\psi_s|^2\)</span>.</p>
<p>Since this procedure does not require the the state <span class="math notranslate nohighlight">\(|\psi\rangle\)</span> to be normalized, ideas along these lines allow to look for variational approximations to the wavefunction <span class="math notranslate nohighlight">\(\psi_s\)</span> in large system sizes, for instance with the help of restricted Boltzmann machines [<a class="reference external" href="https://arxiv.org/abs/1606.02318">arXiv:1606.02318</a>].</p>
<p>The code below performs Monte-Carlo (MC) sampling in the symmetry-reduced Hilbert space. New states are proposed by swapping the spin values on random lattice sites; this update can take a representative state outside the symmetry-reduced basis, and we apply the <cite>basis.representative()</cite> function to project it back. To satisfy Detailed Balance in the MC acceptance/rejection condition, we use the function <cite>basis.get_amp()</cite> to compute the probability ratio in the full (symmetry-free) basis without actually constructing it.</p>
<p>In the example below, we assume that we already have a quantum state <span class="math notranslate nohighlight">\(\psi_s\)</span> in the Fock basis, and we sample the expectation value of an operator <cite>H</cite> using the <cite>*_basis_general</cite> methods <cite>Op_bra_ket()</cite>, <cite>representative()</cite>, and <cite>get_amp()</cite>. These methods do not require to compute the full basis, and thus allow to develop techniques for reaching system sizes beyond exact diagonalization (cf. the <cite>basis</cite> optional argument <cite>make_basis</cite>, as well as <cite>block_order</cite> which can deliver extra speed).</p>
</div>
<div class="section" id="script">
<h1>Script<a class="headerlink" href="#script" title="Permalink to this headline">¶</a></h1>
<p><a class="reference download internal" download="" href="../downloads/560f8fd39e62335be399e802c1b3cbe7/example11.py"><code class="xref download docutils literal notranslate"><span class="pre">download</span> <span class="pre">script</span></code></a></p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>
<span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span><span class="nn">os</span>
<span class="c1"># line 4 and line 5 below are for development purposes and can be removed</span>
<span class="n">qspin_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span><span class="s2">&quot;../../&quot;</span><span class="p">)</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">qspin_path</span><span class="p">)</span>
<span class="c1">###########################################################################</span>
<span class="c1">#                            example 11                                   #</span>
<span class="c1">#  In this script we demonstrate how to use QuSpin&#39;s methods of           #</span>
<span class="c1">#  the general_basis class which do not require explicit calculation      #</span>
<span class="c1">#  of the basis itself. Using the J1-J2 model on a square lattice, we     #</span>
<span class="c1">#  show how  to estimate the energy of a state using Monte-Carlo sampling.#</span>
<span class="c1">###########################################################################</span>
<span class="kn">from</span> <span class="nn">quspin.operators</span> <span class="kn">import</span> <span class="n">hamiltonian</span>
<span class="kn">from</span> <span class="nn">quspin.basis</span> <span class="kn">import</span> <span class="n">spin_basis_general</span>
<span class="kn">from</span> <span class="nn">quspin.operators._make_hamiltonian</span> <span class="kn">import</span> <span class="n">_consolidate_static</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">comb</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#fixes seed of rng</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">time</span> <span class="c1"># timing package</span>
<span class="c1">#</span>
<span class="n">ti</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span> <span class="c1"># start timer</span>
<span class="c1">###### define model parameters ######</span>
<span class="n">J1</span><span class="o">=</span><span class="mf">1.0</span> <span class="c1"># nn interaction</span>
<span class="n">J2</span><span class="o">=</span><span class="mf">0.5</span> <span class="c1"># nnn interaction</span>
<span class="n">Lx</span><span class="p">,</span> <span class="n">Ly</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span> <span class="c1"># linear dimension of 2d lattice</span>
<span class="n">N_2d</span> <span class="o">=</span> <span class="n">Lx</span><span class="o">*</span><span class="n">Ly</span> <span class="c1"># number of sites</span>
<span class="c1">#</span>
<span class="c1">###### setting up user-defined symmetry transformations for 2d lattice ######</span>
<span class="n">sites</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N_2d</span><span class="p">)</span> <span class="c1"># site labels [0,1,2,....]</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">sites</span><span class="o">%</span><span class="n">Lx</span> <span class="c1"># x positions for sites</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">sites</span><span class="o">//</span><span class="n">Lx</span> <span class="c1"># y positions for sites</span>
<span class="c1">#</span>
<span class="n">T_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">Lx</span> <span class="o">+</span> <span class="n">Lx</span><span class="o">*</span><span class="n">y</span> <span class="c1"># translation along x-direction</span>
<span class="n">T_y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span><span class="n">Lx</span><span class="o">*</span><span class="p">((</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">Ly</span><span class="p">)</span> <span class="c1"># translation along y-direction</span>
<span class="c1">#</span>
<span class="n">T_a</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">Lx</span> <span class="o">+</span> <span class="n">Lx</span><span class="o">*</span><span class="p">((</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">Ly</span><span class="p">)</span> <span class="c1"># translation along anti-diagonal</span>
<span class="n">T_d</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">Lx</span> <span class="o">+</span> <span class="n">Lx</span><span class="o">*</span><span class="p">((</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">Ly</span><span class="p">)</span> <span class="c1"># translation along diagonal</span>
<span class="c1">#</span>
<span class="n">P_x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">Lx</span><span class="o">*</span><span class="p">(</span><span class="n">Ly</span><span class="o">-</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># reflection about x-axis</span>
<span class="n">P_y</span> <span class="o">=</span> <span class="p">(</span><span class="n">Lx</span><span class="o">-</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">Lx</span><span class="o">*</span><span class="n">y</span> <span class="c1"># reflection about y-axis</span>
<span class="n">P_d</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">Lx</span><span class="o">*</span><span class="n">x</span> <span class="c1"># reflection about diagonal</span>
<span class="c1">#</span>
<span class="n">Z</span>   <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">sites</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># spin inversion</span>
<span class="c1">#</span>
<span class="c1">###### setting up operator string for Hamiltonian matrix elements H_{ss&#39;} ######</span>
<span class="c1"># setting up site-coupling lists for the J1-J2 model on a 2d square lattice</span>
<span class="n">J1_list</span><span class="o">=</span><span class="p">[[</span><span class="n">J1</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">T_x</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_2d</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[[</span><span class="n">J1</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">T_y</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_2d</span><span class="p">)]</span>
<span class="n">J2_list</span><span class="o">=</span><span class="p">[[</span><span class="n">J2</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">T_d</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_2d</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[[</span><span class="n">J2</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">T_a</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_2d</span><span class="p">)]</span>
<span class="c1"># setting up opstr list</span>
<span class="n">static</span><span class="o">=</span><span class="p">[[</span><span class="s2">&quot;xx&quot;</span><span class="p">,</span><span class="n">J1_list</span><span class="p">],[</span><span class="s2">&quot;yy&quot;</span><span class="p">,</span><span class="n">J1_list</span><span class="p">],[</span><span class="s2">&quot;zz&quot;</span><span class="p">,</span><span class="n">J1_list</span><span class="p">],</span>  <span class="p">[</span><span class="s2">&quot;xx&quot;</span><span class="p">,</span><span class="n">J2_list</span><span class="p">],[</span><span class="s2">&quot;yy&quot;</span><span class="p">,</span><span class="n">J2_list</span><span class="p">],[</span><span class="s2">&quot;zz&quot;</span><span class="p">,</span><span class="n">J2_list</span><span class="p">]]</span>
<span class="c1"># convert static list to format which is easy to use with the basis_general.Op and basis_general.Op_bra_ket methods. </span>
<span class="n">static_formatted</span> <span class="o">=</span> <span class="n">_consolidate_static</span><span class="p">(</span><span class="n">static</span><span class="p">)</span>
<span class="c1">#</span>
<span class="c1">###### setting up basis object without computing the basis (make=False) ######</span>
<span class="n">basis</span> <span class="o">=</span> <span class="n">spin_basis_general</span><span class="p">(</span><span class="n">N_2d</span><span class="p">,</span> <span class="n">pauli</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">make_basis</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
			<span class="n">Nup</span><span class="o">=</span><span class="n">N_2d</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> 
			<span class="n">kxblock</span><span class="o">=</span><span class="p">(</span><span class="n">T_x</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">kyblock</span><span class="o">=</span><span class="p">(</span><span class="n">T_y</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span>
			<span class="n">pxblock</span><span class="o">=</span><span class="p">(</span><span class="n">P_x</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">pyblock</span><span class="o">=</span><span class="p">(</span><span class="n">P_y</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">pdblock</span><span class="o">=</span><span class="p">(</span><span class="n">P_d</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span>
			<span class="n">zblock</span><span class="o">=</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span>
			<span class="n">block_order</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;zblock&#39;</span><span class="p">,</span><span class="s1">&#39;pdblock&#39;</span><span class="p">,</span><span class="s1">&#39;pyblock&#39;</span><span class="p">,</span><span class="s1">&#39;pxblock&#39;</span><span class="p">,</span><span class="s1">&#39;kyblock&#39;</span><span class="p">,</span><span class="s1">&#39;kxblock&#39;</span><span class="p">]</span> <span class="c1"># momentum symmetry comes last for speed</span>
		<span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span> <span class="c1"># examine basis: contains a single element because it is not calculated due to make_basis=False argument above.</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;basis is empty [note argument make_basis=False]&#39;</span><span class="p">)</span>
<span class="c1">#</span>
<span class="c1">###### define quantum state to compute the energy of using Monte-Carlo sampling ######</span>
<span class="c1">#</span>
<span class="c1"># auxiliary basis, only needed for probability_amplitude(); not needed in a proper variational ansatz.</span>
<span class="n">aux_basis</span> <span class="o">=</span> <span class="n">spin_basis_general</span><span class="p">(</span><span class="n">N_2d</span><span class="p">,</span> <span class="n">pauli</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">make_basis</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
			<span class="n">Nup</span><span class="o">=</span><span class="n">N_2d</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> 
			<span class="n">kxblock</span><span class="o">=</span><span class="p">(</span><span class="n">T_x</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">kyblock</span><span class="o">=</span><span class="p">(</span><span class="n">T_y</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span>
			<span class="n">pxblock</span><span class="o">=</span><span class="p">(</span><span class="n">P_x</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">pyblock</span><span class="o">=</span><span class="p">(</span><span class="n">P_y</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">pdblock</span><span class="o">=</span><span class="p">(</span><span class="n">P_d</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span>
			<span class="n">zblock</span><span class="o">=</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span>
			<span class="n">block_order</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;zblock&#39;</span><span class="p">,</span><span class="s1">&#39;pdblock&#39;</span><span class="p">,</span><span class="s1">&#39;pyblock&#39;</span><span class="p">,</span><span class="s1">&#39;pxblock&#39;</span><span class="p">,</span><span class="s1">&#39;kyblock&#39;</span><span class="p">,</span><span class="s1">&#39;kxblock&#39;</span><span class="p">]</span> <span class="c1"># momentum symmetry comes last for speed</span>
		<span class="p">)</span>
<span class="c1"># set quantum state to samplee from to be GS of H </span>
<span class="n">H</span> <span class="o">=</span> <span class="n">hamiltonian</span><span class="p">(</span><span class="n">static</span><span class="p">,[],</span><span class="n">basis</span><span class="o">=</span><span class="n">aux_basis</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="n">E</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">eigsh</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;SA&#39;</span><span class="p">)</span> <span class="c1"># need NOT be (but can be) normalized</span>
<span class="n">psi</span><span class="o">=</span><span class="p">(</span><span class="n">V</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">V</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="c1">#</span>
<span class="c1">##### define proposal function #####</span>
<span class="c1">#</span>
<span class="k">def</span> <span class="nf">swap_bits</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot; Swap bits i, j in integer s.</span>

<span class="sd">	Parameters</span>
<span class="sd">	-----------</span>
<span class="sd">	s: int</span>
<span class="sd">		spin configuration stored in bit representation.</span>
<span class="sd">	i: int</span>
<span class="sd">		lattice site position to be swapped with the corresponding one in j.</span>
<span class="sd">	j: int</span>
<span class="sd">		lattice site position to be swapped with the corresponding one in i.</span>

<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">x</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span><span class="n">s</span><span class="o">&gt;&gt;</span><span class="n">i</span><span class="p">)</span><span class="o">^</span><span class="p">(</span><span class="n">s</span><span class="o">&gt;&gt;</span><span class="n">j</span><span class="p">)</span> <span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span>
	<span class="k">return</span> <span class="n">s</span><span class="o">^</span><span class="p">(</span> <span class="p">(</span><span class="n">x</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="n">x</span><span class="o">&lt;&lt;</span><span class="n">j</span><span class="p">)</span> <span class="p">)</span>
<span class="c1">#</span>
<span class="c1">##### define function to compute the amplitude `psi_s` for every spin configuration `s` #####</span>
<span class="n">basis_state_inds_dict</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">aux_basis</span><span class="o">.</span><span class="n">states</span><span class="p">:</span>
	<span class="n">basis_state_inds_dict</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">aux_basis</span><span class="o">.</span><span class="n">states</span><span class="o">==</span><span class="n">s</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
<span class="k">def</span> <span class="nf">probability_amplitude</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">psi</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39; Computes probability amplitude `psi_s` of quantum state `psi` in z-basis state `s`.</span>

<span class="sd">	Parameters</span>
<span class="sd">	----------</span>
<span class="sd">	s: array_like(int)</span>
<span class="sd">		array of spin configurations [stored in their bit representation] to compute their local energies `E_s`.</span>
<span class="sd">	psi_s: array</span>
<span class="sd">		(unnormalized) probability amplitude values, corresponding to the states `s`. </span>

<span class="sd">	&#39;&#39;&#39;</span>
	<span class="k">return</span> <span class="n">psi</span><span class="p">[[</span><span class="n">basis_state_inds_dict</span><span class="p">[</span><span class="n">ss</span><span class="p">]</span> <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">s</span><span class="p">]]</span>
<span class="c1">#</span>
<span class="c1">##### define function to compute local energy `E_s` #####</span>
<span class="c1">#</span>
<span class="k">def</span> <span class="nf">compute_local_energy</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">psi_s</span><span class="p">,</span><span class="n">psi</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Computes local energy E_s for a spin configuration s.</span>

<span class="sd">	Parameters</span>
<span class="sd">	----------</span>
<span class="sd">	s: array_like(int)</span>
<span class="sd">		array of spin configurations [stored in their bit representation] to compute their local energies `E_s`.</span>
<span class="sd">	psi_s: array</span>
<span class="sd">		(unnormalized) probability amplitude values, corresponding to the states `s` in the symmetry-reduced basis. </span>
<span class="sd">	psi: array</span>
<span class="sd">		(unnormalized) array which encodes the mapping $s \\to \\psi_s$ (e.g. quantum state vector) in the symmetry-reduced basis.</span>
<span class="sd">		</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="c1"># preallocate variable</span>
	<span class="n">E_s</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
	<span class="c1">#</span>
	<span class="c1"># to compute local energy `E_s` we need matrix elements `H_{ss&#39;}` for the operator `H`.</span>
	<span class="c1"># These can be computed by looping overthe static list without constructing the operator matrix. </span>
	<span class="k">for</span> <span class="n">opstr</span><span class="p">,</span><span class="n">indx</span><span class="p">,</span><span class="n">J</span> <span class="ow">in</span> <span class="n">static_formatted</span><span class="p">:</span>
		<span class="c1"># for every state `s`, compute the state it connects to `s&#39;`, and the corresponding matrix element `ME`</span>
		<span class="n">ME</span><span class="p">,</span><span class="n">bras</span><span class="p">,</span><span class="n">kets</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">Op_bra_ket</span><span class="p">(</span><span class="n">opstr</span><span class="p">,</span><span class="n">indx</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">reduce_output</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
		<span class="c1"># performs sum over `s&#39;`</span>
		<span class="n">E_s</span><span class="o">+=</span><span class="n">ME</span> <span class="o">*</span> <span class="n">probability_amplitude</span><span class="p">(</span><span class="n">bras</span><span class="p">,</span><span class="n">psi</span><span class="p">)</span>
	<span class="c1"># normalize by `psi_s`</span>
	<span class="n">E_s</span><span class="o">/=</span><span class="n">psi_s</span>
	<span class="k">return</span> <span class="n">E_s</span> 
<span class="c1">#</span>
<span class="c1">##### perform Monte Carlo sampling from `|psi_s|^2` ##### </span>
<span class="c1">#</span>
<span class="c1"># draw random spin configuratio</span>
<span class="n">s</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_2d</span><span class="o">//</span><span class="mi">2</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_2d</span><span class="o">//</span><span class="mi">2</span><span class="p">)]</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="n">s</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">s</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;random initial state in bit representation:&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="c1"># transform state in bit representation</span>
<span class="n">s</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;same random initial state in integer representation:&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="c1"># compute representative of state `s` under basis symmetries (here only Z-symmetry)</span>
<span class="n">s</span><span class="o">=</span><span class="n">basis</span><span class="o">.</span><span class="n">representative</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;representative of random initial state in integer representation:&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="c1"># compute amplitude in state s</span>
<span class="n">psi_s</span><span class="o">=</span><span class="n">probability_amplitude</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">psi</span><span class="p">)</span>
<span class="c1">#</span>
<span class="n">psi_s_full_basis</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">psi_s</span><span class="p">)</span>
<span class="c1"># overwrite the symmetry-reduced space psi_s_full_basis with its amplitude in the full basis</span>
<span class="n">basis</span><span class="o">.</span><span class="n">get_amp</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">amps</span><span class="o">=</span><span class="n">psi_s_full_basis</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;representative&#39;</span><span class="p">)</span> <span class="c1"># has the advantage that basis need not be made.</span>
<span class="c1">#</span>
<span class="c1"># define MC sampling parameters</span>
<span class="n">equilibration_time</span><span class="o">=</span><span class="mi">200</span>
<span class="n">autocorrelation_time</span><span class="o">=</span><span class="n">N_2d</span>
<span class="c1"># number of MC sampling points</span>
<span class="n">N_MC_points</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="c1">#</span>
<span class="c1">##### run Markov chain MC #####</span>
<span class="c1">#</span>
<span class="c1"># compute all distinct site pairs to swap</span>
<span class="c1">#</span>
<span class="c1"># preallocate variables</span>
<span class="n">E_s</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N_MC_points</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="n">MC_sample</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N_MC_points</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">basis</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span class="c1">#</span>
<span class="n">j</span><span class="o">=</span><span class="mi">0</span> <span class="c1"># set MC chain counter</span>
<span class="n">k</span><span class="o">=</span><span class="mi">0</span> <span class="c1"># set MC sample counter </span>
<span class="k">while</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">N_MC_points</span><span class="p">:</span>
	<span class="c1"># propose new state t by swapping two random bits</span>
	<span class="n">t</span><span class="o">=</span><span class="n">s</span>
	<span class="k">while</span> <span class="n">t</span><span class="o">==</span><span class="n">s</span><span class="p">:</span> <span class="c1"># repeat until a different state is reached</span>
		<span class="c1"># draw two random sites</span>
		<span class="n">site_i</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">N_2d</span><span class="p">)</span>
		<span class="n">site_j</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">N_2d</span><span class="p">)</span>
		<span class="c1"># swap bits in spin configurations</span>
		<span class="n">t</span> <span class="o">=</span> <span class="n">swap_bits</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">site_i</span><span class="p">,</span><span class="n">site_j</span><span class="p">)</span> <span class="c1"># new state t corresponds to integer with swapped bites i and j</span>
	<span class="c1">#</span>
	<span class="c1"># compute representatives or proposed configurations to bring them back to symmetry sector</span>
	<span class="n">t</span><span class="o">=</span><span class="n">basis</span><span class="o">.</span><span class="n">representative</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
	<span class="n">psi_t</span><span class="o">=</span><span class="n">probability_amplitude</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">psi</span><span class="p">)</span>
	<span class="c1"># CAUTION: symmetries break detailed balance which we need to restore by using the amplitudes in the full basis.</span>
	<span class="n">psi_t_full_basis</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">psi_t</span><span class="p">)</span>
	<span class="c1"># overwrite the symmetry-reduced space psi_t_full_basis with its amplitude in the full basis</span>
	<span class="n">basis</span><span class="o">.</span><span class="n">get_amp</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">amps</span><span class="o">=</span><span class="n">psi_t_full_basis</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;representative&#39;</span><span class="p">)</span> <span class="c1"># has the advantage that basis need not be made.</span>
	<span class="c1">#</span>
	<span class="c1">### accept/reject new state</span>
	<span class="c1">#</span>
	<span class="c1"># use amplitudes psi_t_full_basis and psi_s_full_basis to restore detailed balance</span>
	<span class="n">eps</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">eps</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">psi_s_full_basis</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">psi_t_full_basis</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">:</span> 
		<span class="n">s</span><span class="o">=</span><span class="n">t</span>
		<span class="n">psi_s</span><span class="o">=</span><span class="n">psi_t</span>
		<span class="n">psi_s_full_basis</span><span class="o">=</span><span class="n">psi_t_full_basis</span>
	<span class="c1">#</span>
	<span class="c1"># wait for MC chain to quilibrate and collect uncorrelated samples</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">j</span><span class="o">&gt;</span><span class="n">equilibration_time</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">j</span><span class="o">%</span><span class="n">autocorrelation_time</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
		<span class="c1"># compute local energy</span>
		<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;computing local energy E_s for MC sample </span><span class="si">{0:d}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
		<span class="n">E_s</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">compute_local_energy</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">psi_s</span><span class="p">,</span><span class="n">psi</span><span class="p">)</span>
		<span class="c1"># update sample</span>
		<span class="n">MC_sample</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">s</span>
		<span class="c1"># update MC samples counter</span>
		<span class="n">k</span><span class="o">+=</span><span class="mi">1</span>
	<span class="c1">#</span>
	<span class="n">j</span><span class="o">+=</span><span class="mi">1</span> <span class="c1"># update MC chain counter</span>
<span class="c1">#</span>
<span class="c1">##### compute MC-sampled average energy #####</span>
<span class="c1"># compute energy expectation and MC variance</span>
<span class="n">E_mean</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">E_s</span><span class="p">)</span>
<span class="n">E_var_MC</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">E_s</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">N_MC_points</span><span class="p">)</span>
<span class="c1">#</span>
<span class="c1"># compute exact expectation value</span>
<span class="n">E_exact</span><span class="o">=</span><span class="n">H</span><span class="o">.</span><span class="n">expt_value</span><span class="p">(</span><span class="n">psi</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">psi</span><span class="p">))</span>
<span class="c1">#####   compute full basis   #####</span>
<span class="c1"># so far the functions representative(), get_amp(), and Op_bra_ket() did not require to compute the full basis</span>
<span class="n">basis</span><span class="o">.</span><span class="n">make</span><span class="p">(</span><span class="n">Ns_block_est</span><span class="o">=</span><span class="mi">16000</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span> <span class="c1"># after the basis is made, printing the basis returns the states</span>
<span class="c1"># compare results</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;mean energy: </span><span class="si">{0:.4f}</span><span class="s1">, MC variance: </span><span class="si">{1:.4f}</span><span class="s1">, exact energy </span><span class="si">{2:.4f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">E_mean</span><span class="p">,</span> <span class="n">E_var_MC</span><span class="p">,</span> <span class="n">E_exact</span><span class="p">)</span> <span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;simulation took </span><span class="si">{0:.4f}</span><span class="s2"> sec&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">ti</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Monte Carlo Sampling Expectation Values of Obsevables</a></li>
<li><a class="reference internal" href="#physics-setup">Physics Setup</a></li>
<li><a class="reference internal" href="#script">Script</a></li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../sources/examples/example11.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">QuSpin 0.3.7 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Phillip Weinberg, Markus Schmitt and Marin Bukov.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.0.4.
    </div>
  </body>
</html>