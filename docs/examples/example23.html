
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" /><script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-110543543-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
    <title>Gell-Mann Operators for Spin-1 systems &#8212; QuSpin 0.3.7 documentation</title>
    <link rel="stylesheet" href="../static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../static/documentation_options.js"></script>
    <script src="../static/jquery.js"></script>
    <script src="../static/underscore.js"></script>
    <script src="../static/doctools.js"></script>
    <script src="../static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">QuSpin 0.3.7 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <style> .red {color:#ff0000; font-weight:bold; font-style:italic; } </style>
<style> .green {color:#00b200; font-weight:bold; font-style:italic; } </style>
<style> .magenta {color:#FF33F3; font-weight:bold; font-style:italic; } </style>
<style> .orange {color:#FE8E02; font-weight:bold; font-style:italic; } </style><div class="section" id="gell-mann-operators-for-spin-1-systems">
<span id="example23-label"></span><h1>Gell-Mann Operators for Spin-1 systems<a class="headerlink" href="#gell-mann-operators-for-spin-1-systems" title="Permalink to this headline">¶</a></h1>
<p>In this example, we show how to use the <cite>user_basis</cite> class to define the Gell-Mann operators to construct spin-1 Hamiltonians in QuSpin – the SU(3) equivalent of the Pauli operators for spin-1/2.</p>
<p>The eight generators of SU(3), are defined as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\lambda^1 = \begin{pmatrix} 0 &amp; 1 &amp; 0 \\ 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 \end{pmatrix},\quad \lambda^2 = \begin{pmatrix} 0 &amp; -i &amp; 0 \\ i &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 \end{pmatrix}, \quad \lambda^3 = \begin{pmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; -1 &amp; 0 \\ 0 &amp; 0 &amp; 0 \end{pmatrix},\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}\lambda^4 = \begin{pmatrix} 0 &amp; 0 &amp; 1 \\ 0 &amp; 0 &amp; 0 \\ 1 &amp; 0 &amp; 0 \end{pmatrix},\quad \lambda^5 = \begin{pmatrix} 0 &amp; 0 &amp; -i \\ 0 &amp; 0 &amp; 0 \\ i &amp; 0 &amp; 0 \end{pmatrix},\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}\lambda^6 = \begin{pmatrix} 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 \\ 0 &amp; 1 &amp; 0 \end{pmatrix},\quad \lambda^7 = \begin{pmatrix} 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; -i \\ 0 &amp; i &amp; 0 \end{pmatrix}, \quad \lambda^8 = \frac{1}{\sqrt{3}} \begin{pmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; -2 \end{pmatrix}\end{split}\]</div>
<p>We now define them as operator strings for a custom spin-1 <cite>user_basis</cite> (please consult this post – <a class="reference internal" href="../user_basis.html#user-basis-label"><span class="std std-ref">A tutorial on QuSpin’s user_basis</span></a> – for more detailed explanations on using the <cite>user_basis</cite> class). In QuSpin, the basis constructor accepts operator strings of unit length; therefore, we use the operator strings <cite>1</cite>, <cite>2</cite>, <cite>3</cite>, <cite>4</cite>, <cite>5</cite>, <cite>6</cite>, <cite>7</cite>, <cite>8</cite> to denote the operator <span class="math notranslate nohighlight">\(\lambda^j\)</span>.</p>
</div>
<div class="section" id="script">
<h1>Script<a class="headerlink" href="#script" title="Permalink to this headline">¶</a></h1>
<p><a class="reference download internal" download="" href="../downloads/a399bb08443fa74f09b7e38fb20c5511/example23.py"><code class="xref download docutils literal notranslate"><span class="pre">download</span> <span class="pre">script</span></code></a></p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">unicode_literals</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>
<span class="c1">#</span>
<span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span><span class="nn">os</span>
<span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;KMP_DUPLICATE_LIB_OK&#39;</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;True&#39;</span> <span class="c1"># uncomment this line if omp error occurs on OSX for python 3</span>
<span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;OMP_NUM_THREADS&#39;</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;1&#39;</span> <span class="c1"># set number of OpenMP threads to run in parallel</span>
<span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;MKL_NUM_THREADS&#39;</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;1&#39;</span> <span class="c1"># set number of MKL threads to run in parallel</span>
<span class="c1">#</span>
<span class="n">quspin_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span><span class="s2">&quot;../../&quot;</span><span class="p">)</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">quspin_path</span><span class="p">)</span>
<span class="c1">######################################################################</span>
<span class="c1">#                            example 23                              #</span>
<span class="c1"># This example shows how to use the `user_basis` to define Gell-Mann #</span>
<span class="c1"># operators. This allows to construct Hamiltonians using the 8 SU(3) #</span>
<span class="c1"># generators.                                                        #</span>
<span class="c1">######################################################################</span>
<span class="kn">from</span> <span class="nn">quspin.operators</span> <span class="kn">import</span> <span class="n">hamiltonian</span> <span class="c1"># Hamiltonians and operators</span>
<span class="kn">from</span> <span class="nn">quspin.basis</span> <span class="kn">import</span> <span class="n">boson_basis_1d</span> <span class="c1"># Hilbert space spin basis_1d</span>
<span class="kn">from</span> <span class="nn">quspin.basis.user</span> <span class="kn">import</span> <span class="n">user_basis</span> <span class="c1"># Hilbert space user basis</span>
<span class="kn">from</span> <span class="nn">quspin.basis.user</span> <span class="kn">import</span> <span class="n">next_state_sig_32</span><span class="p">,</span><span class="n">op_sig_32</span><span class="p">,</span><span class="n">map_sig_32</span><span class="p">,</span><span class="n">count_particles_sig_32</span> <span class="c1"># user basis data types signatures</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">carray</span><span class="p">,</span><span class="n">cfunc</span> <span class="c1"># numba helper functions</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">uint32</span><span class="p">,</span><span class="n">int32</span><span class="p">,</span><span class="n">float64</span><span class="p">,</span><span class="n">complex128</span> <span class="c1"># numba data types</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">comb</span>
<span class="c1">#</span>
<span class="n">N</span><span class="o">=</span><span class="mi">2</span> <span class="c1"># lattice sites</span>
<span class="n">sps</span><span class="o">=</span><span class="mi">3</span> <span class="c1"># states per site: 3 for a spin-1 system</span>
<span class="n">Np</span><span class="o">=</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span> <span class="c1"># total number of spin-1/s</span>
<span class="c1">#</span>
<span class="c1">############   create boson user basis object   #############</span>
<span class="c1">#</span>
<span class="c1">######  function to call when applying operators</span>
<span class="nd">@cfunc</span><span class="p">(</span><span class="n">op_sig_32</span><span class="p">,</span>
	<span class="nb">locals</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="n">uint32</span><span class="p">,</span><span class="n">occ</span><span class="o">=</span><span class="n">int32</span><span class="p">,</span><span class="n">sps</span><span class="o">=</span><span class="n">uint32</span><span class="p">,</span><span class="n">me_offdiag</span><span class="o">=</span><span class="n">complex128</span><span class="p">,</span><span class="n">me_diag</span><span class="o">=</span><span class="n">float64</span><span class="p">),</span> <span class="p">)</span>
<span class="k">def</span> <span class="nf">op</span><span class="p">(</span><span class="n">op_struct_ptr</span><span class="p">,</span><span class="n">op_str</span><span class="p">,</span><span class="n">site_ind</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">args</span><span class="p">):</span>
	<span class="c1"># using struct pointer to pass op_struct_ptr back to C++ see numba Records</span>
	<span class="n">op_struct</span> <span class="o">=</span> <span class="n">carray</span><span class="p">(</span><span class="n">op_struct_ptr</span><span class="p">,</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span>
	<span class="n">sps</span><span class="o">=</span><span class="mi">3</span>
	<span class="n">me_offdiag</span><span class="o">=</span><span class="mf">1.0</span><span class="p">;</span>
	<span class="n">me_diag</span><span class="o">=</span><span class="mf">1.0</span><span class="p">;</span>
	<span class="c1">#</span>
	<span class="n">site_ind</span> <span class="o">=</span> <span class="n">N</span> <span class="o">-</span> <span class="n">site_ind</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1"># convention for QuSpin for mapping from bits to sites.</span>
	<span class="n">occ</span> <span class="o">=</span> <span class="p">(</span><span class="n">op_struct</span><span class="o">.</span><span class="n">state</span><span class="o">//</span><span class="n">sps</span><span class="o">**</span><span class="n">site_ind</span><span class="p">)</span><span class="o">%</span><span class="n">sps</span> <span class="c1"># occupation</span>
	<span class="n">b</span> <span class="o">=</span> <span class="n">sps</span><span class="o">**</span><span class="n">site_ind</span>
	<span class="c1">#</span>
	<span class="k">if</span> <span class="n">op_str</span><span class="o">==</span><span class="mi">43</span><span class="p">:</span> <span class="c1"># &quot;+&quot; is integer value 43 = ord(&quot;+&quot;)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">occ</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">sps</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
			<span class="n">me_offdiag</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">occ</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">sps</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">me_offdiag</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
		<span class="n">op_struct</span><span class="o">.</span><span class="n">state</span> <span class="o">+=</span> <span class="p">(</span><span class="n">b</span> <span class="k">if</span> <span class="p">(</span><span class="n">occ</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;</span><span class="n">sps</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>

	<span class="k">elif</span> <span class="n">op_str</span><span class="o">==</span><span class="mi">45</span><span class="p">:</span> <span class="c1"># &quot;-&quot; is integer value 45 = ord(&quot;-&quot;)</span>
		<span class="k">if</span> <span class="n">occ</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
			<span class="n">me_offdiag</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">occ</span><span class="p">);</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">me_offdiag</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span><span class="p">);</span>
		<span class="n">op_struct</span><span class="o">.</span><span class="n">state</span> <span class="o">-=</span> <span class="p">(</span><span class="n">b</span> <span class="k">if</span> <span class="n">occ</span><span class="o">&gt;</span><span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>

	<span class="k">elif</span> <span class="n">op_str</span><span class="o">==</span><span class="mi">122</span><span class="p">:</span> <span class="c1"># &quot;z&quot; is integer value 122 = ord(&quot;n&quot;)</span>
		<span class="n">me_diag</span> <span class="o">*=</span> <span class="n">occ</span><span class="o">-</span><span class="mi">1</span>

	<span class="c1"># define the 8 Gell-Mann matrices</span>

	<span class="k">elif</span> <span class="n">op_str</span><span class="o">==</span><span class="mi">49</span><span class="p">:</span> <span class="c1"># &quot;1&quot; is integer value 49 = ord(&quot;1&quot;): lambda_1 Gell-Mann matrix</span>
		<span class="k">if</span> <span class="n">occ</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
			<span class="n">op_struct</span><span class="o">.</span><span class="n">state</span> <span class="o">-=</span> <span class="n">b</span>
		<span class="k">elif</span> <span class="n">occ</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
			<span class="n">op_struct</span><span class="o">.</span><span class="n">state</span> <span class="o">+=</span> <span class="n">b</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">me_offdiag</span> <span class="o">*=</span> <span class="mf">0.0</span>

	<span class="k">elif</span> <span class="n">op_str</span><span class="o">==</span><span class="mi">50</span><span class="p">:</span> <span class="c1"># &quot;2&quot; is integer value 50 = ord(&quot;2&quot;): lambda_2 Gell-Mann matrix</span>
		<span class="k">if</span> <span class="n">occ</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
			<span class="n">op_struct</span><span class="o">.</span><span class="n">state</span> <span class="o">-=</span> <span class="n">b</span>
			<span class="n">me_offdiag</span> <span class="o">*=</span> <span class="mf">1.0</span><span class="n">j</span>
		<span class="k">elif</span> <span class="n">occ</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
			<span class="n">op_struct</span><span class="o">.</span><span class="n">state</span> <span class="o">+=</span> <span class="n">b</span>
			<span class="n">me_offdiag</span> <span class="o">*=</span> <span class="o">-</span><span class="mf">1.0</span><span class="n">j</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">me_offdiag</span> <span class="o">*=</span> <span class="mf">0.0</span>

	<span class="k">elif</span> <span class="n">op_str</span><span class="o">==</span><span class="mi">51</span><span class="p">:</span> <span class="c1"># &quot;3&quot; is integer value 51 = ord(&quot;3&quot;): lambda_3 Gell-Mann matrix</span>
		<span class="k">if</span> <span class="n">occ</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
			<span class="n">me_diag</span><span class="o">*=-</span><span class="mf">1.0</span>
		<span class="k">elif</span> <span class="n">occ</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
			<span class="n">me_diag</span><span class="o">*=</span><span class="mf">0.0</span>

	<span class="k">elif</span> <span class="n">op_str</span><span class="o">==</span><span class="mi">52</span><span class="p">:</span> <span class="c1"># &quot;4&quot; is integer value 52 = ord(&quot;4&quot;): lambda_4 Gell-Mann matrix</span>
		<span class="k">if</span> <span class="n">occ</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
			<span class="n">op_struct</span><span class="o">.</span><span class="n">state</span> <span class="o">-=</span> <span class="mi">2</span><span class="o">*</span><span class="n">b</span>
		<span class="k">elif</span> <span class="n">occ</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
			<span class="n">op_struct</span><span class="o">.</span><span class="n">state</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">b</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">me_offdiag</span> <span class="o">*=</span> <span class="mf">0.0</span>

	<span class="k">elif</span> <span class="n">op_str</span><span class="o">==</span><span class="mi">53</span><span class="p">:</span> <span class="c1"># &quot;5&quot; is integer value 53 = ord(&quot;5&quot;): lambda_5 Gell-Mann matrix</span>
		<span class="k">if</span> <span class="n">occ</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
			<span class="n">op_struct</span><span class="o">.</span><span class="n">state</span> <span class="o">-=</span> <span class="mi">2</span><span class="o">*</span><span class="n">b</span>
			<span class="n">me_offdiag</span> <span class="o">*=</span> <span class="mf">1.0</span><span class="n">j</span>
		<span class="k">elif</span> <span class="n">occ</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
			<span class="n">op_struct</span><span class="o">.</span><span class="n">state</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">b</span>
			<span class="n">me_offdiag</span> <span class="o">*=</span> <span class="o">-</span><span class="mf">1.0</span><span class="n">j</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">me_offdiag</span> <span class="o">*=</span> <span class="mf">0.0</span>

	<span class="k">elif</span> <span class="n">op_str</span><span class="o">==</span><span class="mi">54</span><span class="p">:</span> <span class="c1"># &quot;6&quot; is integer value 54 = ord(&quot;6&quot;): lambda_6 Gell-Mann matrix</span>
		<span class="k">if</span> <span class="n">occ</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
			<span class="n">op_struct</span><span class="o">.</span><span class="n">state</span> <span class="o">-=</span> <span class="n">b</span>
		<span class="k">elif</span> <span class="n">occ</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
			<span class="n">op_struct</span><span class="o">.</span><span class="n">state</span> <span class="o">+=</span> <span class="n">b</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">me_offdiag</span> <span class="o">*=</span> <span class="mf">0.0</span>

	<span class="k">elif</span> <span class="n">op_str</span><span class="o">==</span><span class="mi">55</span><span class="p">:</span> <span class="c1"># &quot;7&quot; is integer value 55 = ord(&quot;7&quot;): lambda_7 Gell-Mann matrix</span>
		<span class="k">if</span> <span class="n">occ</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
			<span class="n">op_struct</span><span class="o">.</span><span class="n">state</span> <span class="o">-=</span> <span class="n">b</span>
			<span class="n">me_offdiag</span> <span class="o">*=</span> <span class="mf">1.0</span><span class="n">j</span>
		<span class="k">elif</span> <span class="n">occ</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
			<span class="n">op_struct</span><span class="o">.</span><span class="n">state</span> <span class="o">+=</span> <span class="n">b</span>
			<span class="n">me_offdiag</span> <span class="o">*=</span> <span class="o">-</span><span class="mf">1.0</span><span class="n">j</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">me_offdiag</span> <span class="o">*=</span> <span class="mf">0.0</span>

	<span class="k">elif</span> <span class="n">op_str</span><span class="o">==</span><span class="mi">56</span><span class="p">:</span> <span class="c1"># &quot;8&quot; is integer value 56 = ord(&quot;8&quot;): lambda_8 Gell-Mann matrix</span>
		<span class="k">if</span> <span class="n">occ</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
			<span class="n">me_diag</span><span class="o">*=</span><span class="mf">1.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span>
		<span class="k">elif</span> <span class="n">occ</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
			<span class="n">me_diag</span><span class="o">*=</span><span class="mf">1.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">me_diag</span><span class="o">*=-</span><span class="mf">2.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span>

	<span class="k">elif</span> <span class="n">op_str</span><span class="o">==</span><span class="mi">73</span><span class="p">:</span> <span class="c1"># &quot;I&quot; is integer value 73 = ord(&quot;I&quot;)</span>
		<span class="k">pass</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="n">me_diag</span> <span class="o">=</span> <span class="mf">0.0</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
	<span class="c1">#</span>
	<span class="n">op_struct</span><span class="o">.</span><span class="n">matrix_ele</span> <span class="o">*=</span> <span class="n">me_diag</span><span class="o">*</span><span class="n">me_offdiag</span>
	<span class="c1">#</span>
	<span class="k">return</span> <span class="n">err</span>
<span class="c1">#</span>
<span class="n">op_args</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sps</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
<span class="c1">######  function to implement magnetization/particle conservation</span>
<span class="c1">#</span>
<span class="nd">@cfunc</span><span class="p">(</span><span class="n">next_state_sig_32</span><span class="p">,</span>
	<span class="nb">locals</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">uint32</span><span class="p">,</span><span class="n">i</span><span class="o">=</span><span class="n">int32</span><span class="p">,</span><span class="n">j</span><span class="o">=</span><span class="n">int32</span><span class="p">,</span><span class="n">n</span><span class="o">=</span><span class="n">int32</span><span class="p">,</span><span class="n">sps</span><span class="o">=</span><span class="n">uint32</span><span class="p">,</span><span class="n">b1</span><span class="o">=</span><span class="n">int32</span><span class="p">,</span><span class="n">b2</span><span class="o">=</span><span class="n">int32</span><span class="p">,</span><span class="n">l</span><span class="o">=</span><span class="n">int32</span><span class="p">,</span><span class="n">n_left</span><span class="o">=</span><span class="n">int32</span><span class="p">),</span> <span class="p">)</span>
<span class="k">def</span> <span class="nf">next_state</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">counter</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">args</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot; implements particle number conservation. Particle number set by initial state, cf `get_s0_pcon()` below. &quot;&quot;&quot;</span>
	<span class="n">t</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
	<span class="n">sps</span><span class="o">=</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
	<span class="n">n</span><span class="o">=</span><span class="mi">0</span> <span class="c1"># running total of number of particles</span>
	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span> <span class="c1"># loop over lattices sites</span>
		<span class="n">b1</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span><span class="o">//</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">%</span><span class="n">sps</span> <span class="c1"># get occupation at site i</span>
		<span class="k">if</span> <span class="n">b1</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span> <span class="c1"># if there is a boson</span>
			<span class="n">n</span> <span class="o">+=</span> <span class="n">b1</span>
			<span class="n">b2</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span><span class="o">/</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">%</span><span class="n">sps</span> <span class="c1"># get occupation st site ahead</span>
			<span class="k">if</span> <span class="n">b2</span><span class="o">&lt;</span><span class="p">(</span><span class="n">sps</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span> <span class="c1"># if I can move a boson to this site</span>
				<span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span> <span class="c1"># decrease one from the running total</span>
				<span class="n">t</span> <span class="o">-=</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="c1"># remove one boson from site i</span>
				<span class="n">t</span> <span class="o">+=</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># add one boson to site i+1</span>
				<span class="k">if</span> <span class="n">n</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span> <span class="c1"># if any bosons left</span>
					<span class="c1"># so far: moved one boson forward;</span>
					<span class="c1"># now: take rest of bosons and fill first l sites with maximum occupation</span>
					<span class="c1"># to keep lexigraphic order</span>
					<span class="n">l</span> <span class="o">=</span> <span class="n">n</span><span class="o">//</span><span class="p">(</span><span class="n">sps</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># how many sites can be fully occupied with n bosons</span>
					<span class="n">n_left</span> <span class="o">=</span> <span class="n">n</span><span class="o">%</span><span class="p">(</span><span class="n">sps</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># leftover of particles on not maximally occupied sites</span>
					<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
						<span class="n">t</span> <span class="o">-=</span> <span class="p">(</span><span class="n">t</span><span class="o">//</span><span class="n">args</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">%</span><span class="n">sps</span> <span class="o">*</span> <span class="n">args</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
						<span class="k">if</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">l</span><span class="p">:</span> <span class="c1"># fill in with maximal occupation</span>
							<span class="n">t</span> <span class="o">+=</span> <span class="p">(</span><span class="n">sps</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">args</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
						<span class="k">elif</span> <span class="n">j</span><span class="o">==</span><span class="n">l</span><span class="p">:</span> <span class="c1"># fill with leftover</span>
							<span class="n">t</span> <span class="o">+=</span> <span class="n">n_left</span><span class="o">*</span><span class="n">args</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
				<span class="k">break</span> <span class="c1"># stop loop</span>
	<span class="k">return</span> <span class="n">t</span>
<span class="n">next_state_args</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sps</span><span class="o">**</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
<span class="c1"># python function to calculate the starting state to generate the particle conserving basis</span>
<span class="k">def</span> <span class="nf">get_s0_pcon</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">Np</span><span class="p">):</span>
	<span class="n">sps</span> <span class="o">=</span> <span class="mi">3</span> <span class="c1"># use as global variable</span>
	<span class="n">l</span> <span class="o">=</span> <span class="n">Np</span><span class="o">//</span><span class="p">(</span><span class="n">sps</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="n">s</span>  <span class="o">=</span> <span class="nb">sum</span><span class="p">((</span><span class="n">sps</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">sps</span><span class="o">**</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l</span><span class="p">))</span>
	<span class="n">s</span> <span class="o">+=</span> <span class="p">(</span><span class="n">Np</span><span class="o">%</span><span class="p">(</span><span class="n">sps</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">sps</span><span class="o">**</span><span class="n">l</span>
	<span class="k">return</span> <span class="n">s</span>
<span class="c1"># python function to calculate the size of the particle-conserved basis, i.e.</span>
<span class="c1"># BEFORE applying pre_check_state and symmetry maps</span>
<span class="k">def</span> <span class="nf">get_Ns_pcon</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">Np</span><span class="p">):</span>
	<span class="n">Ns</span><span class="o">=</span><span class="mi">0</span>
	<span class="n">sps</span><span class="o">=</span><span class="mi">3</span>
	<span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Np</span><span class="o">//</span><span class="n">sps</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
		<span class="n">r_2</span> <span class="o">=</span> <span class="n">Np</span> <span class="o">-</span> <span class="n">r</span><span class="o">*</span><span class="n">sps</span>
		<span class="k">if</span> <span class="n">r</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
			<span class="n">Ns</span> <span class="o">+=</span>  <span class="n">comb</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">*</span> <span class="n">comb</span><span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="n">r_2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span><span class="n">r_2</span><span class="p">,</span><span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">Ns</span> <span class="o">+=</span> <span class="o">-</span><span class="n">comb</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">*</span> <span class="n">comb</span><span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="n">r_2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span><span class="n">r_2</span><span class="p">,</span><span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

	<span class="k">return</span> <span class="n">Ns</span>
<span class="c1">#</span>
<span class="c1">######  define symmetry maps</span>
<span class="c1">#</span>
<span class="nd">@cfunc</span><span class="p">(</span><span class="n">map_sig_32</span><span class="p">,</span>
	<span class="nb">locals</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">shift</span><span class="o">=</span><span class="n">uint32</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">uint32</span><span class="p">,</span><span class="n">sps</span><span class="o">=</span><span class="n">uint32</span><span class="p">,</span><span class="n">i</span><span class="o">=</span><span class="n">int32</span><span class="p">,</span><span class="n">j</span><span class="o">=</span><span class="n">int32</span><span class="p">,)</span> <span class="p">)</span>
<span class="k">def</span> <span class="nf">translation</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">sign_ptr</span><span class="p">,</span><span class="n">args</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot; works for all system sizes N. &quot;&quot;&quot;</span>
	<span class="n">out</span> <span class="o">=</span> <span class="mi">0</span>
	<span class="n">shift</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="n">sps</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
		<span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">shift</span><span class="o">+</span><span class="n">N</span><span class="p">)</span><span class="o">%</span><span class="n">N</span>
		<span class="n">out</span> <span class="o">+=</span> <span class="p">(</span> <span class="n">x</span><span class="o">%</span><span class="n">sps</span> <span class="p">)</span> <span class="o">*</span> <span class="n">sps</span><span class="o">**</span><span class="n">j</span>
		<span class="n">x</span> <span class="o">//=</span> <span class="n">sps</span>
	<span class="c1">#</span>
	<span class="k">return</span> <span class="n">out</span>
<span class="n">T_args</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="n">sps</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
<span class="c1">#</span>
<span class="nd">@cfunc</span><span class="p">(</span><span class="n">map_sig_32</span><span class="p">,</span>
	<span class="nb">locals</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">out</span><span class="o">=</span><span class="n">uint32</span><span class="p">,</span><span class="n">sps</span><span class="o">=</span><span class="n">uint32</span><span class="p">,</span><span class="n">i</span><span class="o">=</span><span class="n">int32</span><span class="p">,</span><span class="n">j</span><span class="o">=</span><span class="n">int32</span><span class="p">)</span> <span class="p">)</span>
<span class="k">def</span> <span class="nf">parity</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">sign_ptr</span><span class="p">,</span><span class="n">args</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot; works for all system sizes N. &quot;&quot;&quot;</span>
	<span class="n">out</span> <span class="o">=</span> <span class="mi">0</span>
	<span class="n">sps</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
		<span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span>
		<span class="n">out</span> <span class="o">+=</span> <span class="p">(</span> <span class="n">x</span><span class="o">%</span><span class="n">sps</span> <span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">sps</span><span class="o">**</span><span class="n">j</span><span class="p">)</span>
		<span class="n">x</span> <span class="o">//=</span> <span class="n">sps</span>
	<span class="c1">#</span>
	<span class="k">return</span> <span class="n">out</span>
<span class="n">P_args</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sps</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
<span class="c1">#</span>
<span class="nd">@cfunc</span><span class="p">(</span><span class="n">map_sig_32</span><span class="p">,</span>
	<span class="nb">locals</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">out</span><span class="o">=</span><span class="n">uint32</span><span class="p">,</span><span class="n">sps</span><span class="o">=</span><span class="n">uint32</span><span class="p">,</span><span class="n">i</span><span class="o">=</span><span class="n">int32</span><span class="p">)</span> <span class="p">)</span>
<span class="k">def</span> <span class="nf">inversion</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">sign_ptr</span><span class="p">,</span><span class="n">args</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot; works for all system sizes N. &quot;&quot;&quot;</span>
	<span class="n">out</span> <span class="o">=</span> <span class="mi">0</span>

	<span class="n">sps</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
		<span class="n">out</span> <span class="o">+=</span> <span class="p">(</span> <span class="n">sps</span><span class="o">-</span><span class="n">x</span><span class="o">%</span><span class="n">sps</span><span class="o">-</span><span class="mi">1</span> <span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">sps</span><span class="o">**</span><span class="n">i</span><span class="p">)</span>
		<span class="n">x</span> <span class="o">//=</span> <span class="n">sps</span>
	<span class="c1">#</span>
	<span class="k">return</span> <span class="n">out</span>
<span class="n">Z_args</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sps</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
<span class="c1">#</span>
<span class="c1">######  define function to count particles in bit representation</span>
<span class="c1">#</span>
<span class="nd">@cfunc</span><span class="p">(</span><span class="n">count_particles_sig_32</span><span class="p">,</span>
	<span class="nb">locals</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">uint32</span><span class="p">,))</span>
<span class="k">def</span> <span class="nf">count_particles</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">p_number_ptr</span><span class="p">,</span><span class="n">args</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot; Counts number of particles/spin-ups in a state stored in integer representation for up to N=32 sites &quot;&quot;&quot;</span>
	<span class="c1">#</span>
	<span class="n">s</span> <span class="o">=</span> <span class="n">x</span> <span class="c1"># integer x cannot be changed</span>
	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
		<span class="n">p_number_ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">s</span><span class="o">%</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
		<span class="n">s</span> <span class="o">/=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">n_sectors</span><span class="o">=</span><span class="mi">1</span> <span class="c1"># number of particle sectors</span>
<span class="n">count_particles_args</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">N</span><span class="p">,</span><span class="n">sps</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="c1">#</span>
<span class="c1">######  construct user_basis</span>
<span class="c1"># define maps dict</span>
<span class="n">maps</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">T_block</span><span class="o">=</span><span class="p">(</span><span class="n">translation</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">T_args</span><span class="p">),</span><span class="n">P_block</span><span class="o">=</span><span class="p">(</span><span class="n">parity</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">P_args</span><span class="p">),</span> <span class="p">)</span> <span class="c1">#Z_block=(inversion,2,0,Z_args), )</span>
<span class="c1"># define particle conservation and op dicts</span>
<span class="n">pcon_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">Np</span><span class="o">=</span><span class="n">Np</span><span class="p">,</span><span class="n">next_state</span><span class="o">=</span><span class="n">next_state</span><span class="p">,</span><span class="n">next_state_args</span><span class="o">=</span><span class="n">next_state_args</span><span class="p">,</span>
				 <span class="n">get_Ns_pcon</span><span class="o">=</span><span class="n">get_Ns_pcon</span><span class="p">,</span><span class="n">get_s0_pcon</span><span class="o">=</span><span class="n">get_s0_pcon</span><span class="p">,</span>
				 <span class="n">count_particles</span><span class="o">=</span><span class="n">count_particles</span><span class="p">,</span><span class="n">count_particles_args</span><span class="o">=</span><span class="n">count_particles_args</span><span class="p">,</span><span class="n">n_sectors</span><span class="o">=</span><span class="n">n_sectors</span><span class="p">)</span>
<span class="n">op_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="n">op</span><span class="p">,</span><span class="n">op_args</span><span class="o">=</span><span class="n">op_args</span><span class="p">)</span>
<span class="c1"># create user basiss</span>
<span class="n">basis</span> <span class="o">=</span> <span class="n">user_basis</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">op_dict</span><span class="p">,</span><span class="n">allowed_ops</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="s2">&quot;+-zI12345678&quot;</span><span class="p">),</span>  <span class="n">sps</span><span class="o">=</span><span class="n">sps</span><span class="p">,</span> <span class="o">**</span><span class="n">maps</span><span class="p">,</span> <span class="p">)</span> <span class="c1"># pcon_dict=pcon_dict)</span>
<span class="c1">#</span>
<span class="nb">print</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span>
<span class="c1">#</span>
<span class="c1">############   create Hamiltonian   #############</span>
<span class="c1">#</span>
<span class="n">J</span><span class="o">=-</span><span class="mf">1.0</span>
<span class="n">U</span><span class="o">=+</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
<span class="n">h</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">7.0</span><span class="p">)</span>
<span class="c1">#</span>
<span class="n">nn_int</span><span class="o">=</span><span class="p">[[</span><span class="o">+</span><span class="n">J</span><span class="p">,</span><span class="n">j</span><span class="p">,(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">N</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
<span class="n">onsite_int</span><span class="o">=</span><span class="p">[[</span><span class="n">U</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
<span class="n">onsite_field</span><span class="o">=</span><span class="p">[[</span><span class="n">h</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
<span class="c1">#</span>
<span class="n">static</span><span class="o">=</span><span class="p">[[</span><span class="s2">&quot;11&quot;</span><span class="p">,</span><span class="n">nn_int</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;22&quot;</span><span class="p">,</span><span class="n">nn_int</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;88&quot;</span><span class="p">,</span><span class="n">onsite_int</span><span class="p">],[</span><span class="s2">&quot;5&quot;</span><span class="p">,</span><span class="n">onsite_field</span><span class="p">],</span> <span class="p">]</span>
<span class="n">dynamic</span><span class="o">=</span><span class="p">[]</span>
<span class="c1">#</span>
<span class="n">no_checks</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">check_symm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">check_pcon</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">check_herm</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">H</span><span class="o">=</span><span class="n">hamiltonian</span><span class="p">(</span><span class="n">static</span><span class="p">,[],</span><span class="n">basis</span><span class="o">=</span><span class="n">basis</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">,</span><span class="o">**</span><span class="n">no_checks</span><span class="p">)</span>
<span class="c1">#</span>
<span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span> <span class="p">)</span>


</pre></div>
</td></tr></table></div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Gell-Mann Operators for Spin-1 systems</a></li>
<li><a class="reference internal" href="#script">Script</a></li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../sources/examples/example23.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">QuSpin 0.3.7 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Phillip Weinberg, Markus Schmitt and Marin Bukov.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.0.4.
    </div>
  </body>
</html>